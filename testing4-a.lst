CCS PCM C Compiler, Version 4.013, 28193               12-Jul-12 12:25

               Filename: C:\Users\Amaya\Desktop\only B0\testing\testing4-a.lst

               ROM used: 1057 words (13%)
                         Largest free fragment is 2048
               RAM used: 31 (8%) at main() level
                         50 (14%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   2F5
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.5
001A:  GOTO   01D
001B:  BTFSC  0B.2
001C:  GOTO   034
001D:  BTFSS  0B.4
001E:  GOTO   021
001F:  BTFSC  0B.1
0020:  GOTO   037
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   27,W
002C:  MOVWF  7B
002D:  MOVF   20,W
002E:  MOVWF  0A
002F:  SWAPF  21,W
0030:  MOVWF  03
0031:  SWAPF  7F,F
0032:  SWAPF  7F,W
0033:  RETFIE
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   094
0037:  BCF    0A.3
0038:  BCF    0A.4
0039:  GOTO   0D2
.................... #include "p1.h" 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES HS                    	//High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                 	//No Power Up Timer 
.................... #FUSES NOPROTECT             	//Code not protected from reading 
.................... #FUSES NODEBUG               	//No Debug mode for ICD 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
.................... #FUSES NOWRT                 	//Program memory not write protected 
....................  
.................... #use delay(clock=20000000) 
*
00BE:  MOVLW  4B
00BF:  MOVWF  04
00C0:  BCF    03.7
00C1:  MOVF   00,W
00C2:  BTFSC  03.2
00C3:  GOTO   0D1
00C4:  MOVLW  06
00C5:  MOVWF  78
00C6:  CLRF   77
00C7:  DECFSZ 77,F
00C8:  GOTO   0C7
00C9:  DECFSZ 78,F
00CA:  GOTO   0C6
00CB:  MOVLW  7B
00CC:  MOVWF  77
00CD:  DECFSZ 77,F
00CE:  GOTO   0CD
00CF:  DECFSZ 00,F
00D0:  GOTO   0C4
00D1:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define INTS_PER_mS 19         // (20000000/(4*256*1*1000)) 
....................                                //  20000000/4 = 5000000 -> internal clock 
....................                                //  5000000/256 = 19531.25 -> RTCC roll over 
....................                                //  19531.25/1 = 19531.25 -> RTCC_DIV_1 
....................                                //  19531.25/1000 = 19.53125 -> miliseconds 
....................  
.................... #define MAX_CROSSING_TIME 2000   // the maximum time for a person to cross two beams 
.................... #define MIN_CROSSING_TIME 4    // the minimum time for a person to cross two beams 
.................... #define MIN_DELAY_BETWEEN_TWO_INTERRUPTS 1  
....................  
....................  
....................  
....................  
.................... #include "flex_lcd.c" 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board,  
.................... // which is what I used to test the driver.  Change these  
.................... // pins to fit your own board.  
....................  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_D5  
.................... #define LCD_DB6   PIN_D6  
.................... #define LCD_DB7   PIN_D7  
....................  
.................... /*#define LCD_E     PIN_A1 
.................... #define LCD_RS    PIN_A3  
.................... #define LCD_RW    PIN_A2 */ 
....................  
.................... /*#define LCD_E     PIN_C4 
.................... #define LCD_RS    PIN_C5 
.................... #define LCD_RW    PIN_C6*/ 
....................  
.................... #define LCD_RS    PIN_D1 
.................... #define LCD_RW    PIN_D2 
.................... #define LCD_E     PIN_D3 
....................  
....................  
....................  
.................... // If you only want a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  
....................  
.................... #define USE_LCD_RW   1       
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines  
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line  
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots  
....................  0xc,                    // Display on  
....................  1,                      // Clear display  
....................  6                       // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0170:  BTFSC  49.0
0171:  GOTO   174
0172:  BCF    08.4
0173:  GOTO   175
0174:  BSF    08.4
0175:  BSF    03.5
0176:  BCF    08.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0177:  BCF    03.5
0178:  BTFSC  49.1
0179:  GOTO   17C
017A:  BCF    08.5
017B:  GOTO   17D
017C:  BSF    08.5
017D:  BSF    03.5
017E:  BCF    08.5
....................  output_bit(LCD_DB6, !!(nibble & 4));     
017F:  BCF    03.5
0180:  BTFSC  49.2
0181:  GOTO   184
0182:  BCF    08.6
0183:  GOTO   185
0184:  BSF    08.6
0185:  BSF    03.5
0186:  BCF    08.6
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0187:  BCF    03.5
0188:  BTFSC  49.3
0189:  GOTO   18C
018A:  BCF    08.7
018B:  GOTO   18D
018C:  BSF    08.7
018D:  BSF    03.5
018E:  BCF    08.7
....................   
....................  delay_cycles(1);  
018F:  NOP
....................  output_high(LCD_E);  
0190:  BCF    08.3
0191:  BCF    03.5
0192:  BSF    08.3
....................  delay_us(2);  
0193:  MOVLW  03
0194:  MOVWF  77
0195:  DECFSZ 77,F
0196:  GOTO   195
....................  output_low(LCD_E);  
0197:  BSF    03.5
0198:  BCF    08.3
0199:  BCF    03.5
019A:  BCF    08.3
.................... }  
019B:  RETLW  00
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
019C:  CLRF   4A
....................      
.................... output_high(LCD_E);  
019D:  BSF    03.5
019E:  BCF    08.3
019F:  BCF    03.5
01A0:  BSF    08.3
.................... delay_cycles(1);  
01A1:  NOP
....................  
.................... retval_0 = input(LCD_DB4);  
01A2:  BSF    03.5
01A3:  BSF    08.4
01A4:  BCF    03.5
01A5:  BCF    4A.0
01A6:  BTFSC  08.4
01A7:  BSF    4A.0
.................... retval_1 = input(LCD_DB5);  
01A8:  BSF    03.5
01A9:  BSF    08.5
01AA:  BCF    03.5
01AB:  BCF    4A.1
01AC:  BTFSC  08.5
01AD:  BSF    4A.1
.................... retval_2 = input(LCD_DB6);  
01AE:  BSF    03.5
01AF:  BSF    08.6
01B0:  BCF    03.5
01B1:  BCF    4A.2
01B2:  BTFSC  08.6
01B3:  BSF    4A.2
.................... retval_3 = input(LCD_DB7);  
01B4:  BSF    03.5
01B5:  BSF    08.7
01B6:  BCF    03.5
01B7:  BCF    4A.3
01B8:  BTFSC  08.7
01B9:  BSF    4A.3
....................    
.................... output_low(LCD_E);  
01BA:  BSF    03.5
01BB:  BCF    08.3
01BC:  BCF    03.5
01BD:  BCF    08.3
....................      
.................... return(retval);     
01BE:  MOVF   4A,W
01BF:  MOVWF  78
.................... }     
01C0:  RETLW  00
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_LCD_RW  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
*
01C5:  BSF    03.5
01C6:  BCF    08.2
01C7:  BCF    03.5
01C8:  BSF    08.2
.................... delay_cycles(1);  
01C9:  NOP
....................  
.................... high = lcd_read_nibble();  
01CA:  CALL   19C
01CB:  MOVF   78,W
01CC:  MOVWF  49
....................  
.................... low = lcd_read_nibble();  
01CD:  CALL   19C
01CE:  MOVF   78,W
01CF:  MOVWF  48
....................  
.................... return( (high<<4) | low);  
01D0:  SWAPF  49,W
01D1:  MOVWF  77
01D2:  MOVLW  F0
01D3:  ANDWF  77,F
01D4:  MOVF   77,W
01D5:  IORWF  48,W
01D6:  MOVWF  78
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
*
01C1:  BSF    03.5
01C2:  BCF    08.1
01C3:  BCF    03.5
01C4:  BCF    08.1
....................  
.................... #ifdef USE_LCD_RW  
.................... while(bit_test(lcd_read_byte(),7)) ;  
*
01D7:  MOVF   78,W
01D8:  MOVWF  48
01D9:  BTFSC  48.7
01DA:  GOTO   1C5
.................... #else  
.................... delay_us(60);   
.................... #endif  
....................  
.................... if(address)  
01DB:  MOVF   46,F
01DC:  BTFSC  03.2
01DD:  GOTO   1E3
....................    output_high(LCD_RS);  
01DE:  BSF    03.5
01DF:  BCF    08.1
01E0:  BCF    03.5
01E1:  BSF    08.1
.................... else  
01E2:  GOTO   1E7
....................    output_low(LCD_RS);  
01E3:  BSF    03.5
01E4:  BCF    08.1
01E5:  BCF    03.5
01E6:  BCF    08.1
....................        
....................  delay_cycles(1);  
01E7:  NOP
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
01E8:  BSF    03.5
01E9:  BCF    08.2
01EA:  BCF    03.5
01EB:  BCF    08.2
.................... delay_cycles(1);  
01EC:  NOP
.................... #endif  
....................  
.................... output_low(LCD_E);  
01ED:  BSF    03.5
01EE:  BCF    08.3
01EF:  BCF    03.5
01F0:  BCF    08.3
....................  
.................... lcd_send_nibble(n >> 4);  
01F1:  SWAPF  47,W
01F2:  MOVWF  48
01F3:  MOVLW  0F
01F4:  ANDWF  48,F
01F5:  MOVF   48,W
01F6:  MOVWF  49
01F7:  CALL   170
.................... lcd_send_nibble(n & 0xf);  
01F8:  MOVF   47,W
01F9:  ANDLW  0F
01FA:  MOVWF  48
01FB:  MOVWF  49
01FC:  CALL   170
.................... }  
01FD:  RETLW  00
....................  
.................... //----------------------------  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... output_low(LCD_RS);  
*
0320:  BSF    03.5
0321:  BCF    08.1
0322:  BCF    03.5
0323:  BCF    08.1
....................  
.................... #ifdef USE_LCD_RW  
.................... output_low(LCD_RW);  
0324:  BSF    03.5
0325:  BCF    08.2
0326:  BCF    03.5
0327:  BCF    08.2
.................... #endif  
....................  
.................... output_low(LCD_E);  
0328:  BSF    03.5
0329:  BCF    08.3
032A:  BCF    03.5
032B:  BCF    08.3
032C:  CLRF   28
032D:  BTFSC  0B.7
032E:  BSF    28.7
032F:  BCF    0B.7
....................  
.................... delay_ms(15);  
0330:  MOVLW  0F
0331:  MOVWF  4B
0332:  CALL   0BE
0333:  BTFSC  28.7
0334:  BSF    0B.7
....................  
.................... for(i=0 ;i < 3; i++)  
0335:  CLRF   39
0336:  MOVF   39,W
0337:  SUBLW  02
0338:  BTFSS  03.0
0339:  GOTO   348
....................    {  
....................     lcd_send_nibble(0x03);  
033A:  MOVLW  03
033B:  MOVWF  49
033C:  CALL   170
033D:  CLRF   28
033E:  BTFSC  0B.7
033F:  BSF    28.7
0340:  BCF    0B.7
....................     delay_ms(5);  
0341:  MOVLW  05
0342:  MOVWF  4B
0343:  CALL   0BE
0344:  BTFSC  28.7
0345:  BSF    0B.7
....................    }  
0346:  INCF   39,F
0347:  GOTO   336
....................  
.................... lcd_send_nibble(0x02);  
0348:  MOVLW  02
0349:  MOVWF  49
034A:  CALL   170
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
034B:  CLRF   39
034C:  MOVF   39,W
034D:  SUBLW  03
034E:  BTFSS  03.0
034F:  GOTO   359
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
0350:  MOVF   39,W
0351:  CALL   03A
0352:  MOVWF  3A
0353:  CLRF   46
0354:  MOVF   3A,W
0355:  MOVWF  47
0356:  CALL   1C1
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 60 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_LCD_RW  
....................     delay_ms(5);  
....................     #endif  
....................    }  
0357:  INCF   39,F
0358:  GOTO   34C
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
.................... if(y != 1)  
*
01FE:  DECFSZ 43,W
01FF:  GOTO   201
0200:  GOTO   204
....................    address = lcd_line_two;  
0201:  MOVLW  40
0202:  MOVWF  44
.................... else  
0203:  GOTO   205
....................    address=0;  
0204:  CLRF   44
.................... address += x-1;  
0205:  MOVLW  01
0206:  SUBWF  42,W
0207:  ADDWF  44,F
.................... lcd_send_byte(0, 0x80 | address);  
0208:  MOVF   44,W
0209:  IORLW  80
020A:  MOVWF  45
020B:  CLRF   46
020C:  MOVF   45,W
020D:  MOVWF  47
020E:  CALL   1C1
.................... }  
020F:  RETLW  00
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
....................    {  
0210:  MOVF   41,W
0211:  XORLW  0C
0212:  BTFSC  03.2
0213:  GOTO   21B
0214:  XORLW  06
0215:  BTFSC  03.2
0216:  GOTO   229
0217:  XORLW  02
0218:  BTFSC  03.2
0219:  GOTO   22F
021A:  GOTO   234
....................     case '\f':  
....................       lcd_send_byte(0,1);  
021B:  CLRF   46
021C:  MOVLW  01
021D:  MOVWF  47
021E:  CALL   1C1
021F:  CLRF   28
0220:  BTFSC  0B.7
0221:  BSF    28.7
0222:  BCF    0B.7
....................       delay_ms(2);  
0223:  MOVLW  02
0224:  MOVWF  4B
0225:  CALL   0BE
0226:  BTFSC  28.7
0227:  BSF    0B.7
....................       break;  
0228:  GOTO   23A
....................      
....................     case '\n':  
....................        lcd_gotoxy(1,2);  
0229:  MOVLW  01
022A:  MOVWF  42
022B:  MOVLW  02
022C:  MOVWF  43
022D:  CALL   1FE
....................        break;  
022E:  GOTO   23A
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
022F:  CLRF   46
0230:  MOVLW  10
0231:  MOVWF  47
0232:  CALL   1C1
....................        break;  
0233:  GOTO   23A
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
0234:  MOVLW  01
0235:  MOVWF  46
0236:  MOVF   41,W
0237:  MOVWF  47
0238:  CALL   1C1
....................        break;  
0239:  GOTO   23A
....................    }  
.................... }  
023A:  RETLW  00
....................  
.................... //------------------------------  
.................... #ifdef USE_LCD_RW  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(lcd_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
....................  
.................... void init_pic(); 
.................... void setTimer(); 
.................... int checkTimer(); 
.................... void rayCrossed_isr(); 
.................... void clock_isr(); 
.................... int32 convertToCelsius(); 
.................... int convertToASCII(int16 number); 
.................... void lcd_display(int16 number, int x, int y); 
.................... void initialDisplay(); 
.................... int16 read_temperature(); 
.................... void lcd_display_temperature(); 
.................... void phaseControl(); 
....................  
.................... int16 noOfPeople = 0;    // Number of people inside the room 
*
0308:  BCF    03.5
0309:  CLRF   29
030A:  CLRF   2A
.................... int int_count;         // Number of interrupts left before a second has elapsed 
.................... int unitsPosition, tensPosition, hundredsPosition; 
....................  
.................... int1 rayOne = 0;       // to record when first beam get crossed 
030B:  BCF    2F.0
.................... int1 rayTwo = 0;       // to record when second beam get crossed 
030C:  BCF    2F.1
.................... int1 pin_changed = 1; 
030D:  BSF    2F.2
.................... int1 number_changed = 1; 
030E:  BSF    2F.3
.................... int1 temp_changed=1; 
030F:  BSF    2F.4
....................  
.................... int16 mseconds =0; 
0310:  CLRF   30
0311:  CLRF   31
....................  
.................... int16 temperature;     // The A/D conversion of the analog input 
....................                        // signal results in a corresponding 10-bit digital number. 
....................                        // this variable is to store that 
....................  
.................... int16 t;           // The A/D conversion of the analog input 
....................                    // signal results in a corresponding 10-bit digital number. 
....................                    // this variable is to store that 
.................... int16 pre_t=0; 
0312:  CLRF   36
0313:  CLRF   37
....................  
.................... void main() 
.................... { 
*
02F5:  CLRF   04
02F6:  BCF    03.7
02F7:  MOVLW  1F
02F8:  ANDWF  03,F
02F9:  MOVLW  81
02FA:  BSF    03.5
02FB:  MOVWF  19
02FC:  MOVLW  A6
02FD:  MOVWF  18
02FE:  MOVLW  90
02FF:  BCF    03.5
0300:  MOVWF  18
0301:  BSF    03.5
0302:  BSF    1F.0
0303:  BSF    1F.1
0304:  BSF    1F.2
0305:  BCF    1F.3
0306:  MOVLW  07
0307:  MOVWF  1C
....................    init_pic(); 
*
0316:  GOTO   0FF
0317:  CLRF   28
0318:  BTFSC  0B.7
0319:  BSF    28.7
031A:  BCF    0B.7
....................  
....................      initialDisplay(); 
....................    OUTPUT_HIGH(PIN_C0); 
*
0314:  MOVLW  FF
0315:  MOVWF  38
*
03B1:  BCF    38.0
03B2:  MOVF   38,W
03B3:  BSF    03.5
03B4:  MOVWF  07
03B5:  BCF    03.5
03B6:  BSF    07.0
....................    OUTPUT_HIGH(PIN_C2); 
03B7:  BCF    38.2
03B8:  MOVF   38,W
03B9:  BSF    03.5
03BA:  MOVWF  07
03BB:  BCF    03.5
03BC:  BSF    07.2
....................    OUTPUT_LOW(PIN_C3); 
03BD:  BCF    38.3
03BE:  MOVF   38,W
03BF:  BSF    03.5
03C0:  MOVWF  07
03C1:  BCF    03.5
03C2:  BCF    07.3
....................  
....................        while(1) 
....................        { 
....................      //  if(number_changed) 
....................     //   { 
....................          lcd_display(noOfPeople,14,1); 
03C3:  MOVF   2A,W
03C4:  MOVWF  3A
03C5:  MOVF   29,W
03C6:  MOVWF  39
03C7:  MOVLW  0E
03C8:  MOVWF  3B
03C9:  MOVLW  01
03CA:  MOVWF  3C
03CB:  CALL   269
....................     //     number_changed=0; 
....................     //   } 
....................      //  if(temp_changed) 
....................       // { 
....................          lcd_display_temperature(); 
....................       //   temp_changed=0; 
....................      //  } 
....................        //  phaseControl(); 
....................        } 
*
041F:  GOTO   3C3
....................  
.................... } 
....................  
....................  
....................  
.................... /* when timer0 counter overflows(0-255) an interrup occurs. int count which is initially 
....................  * set to INTS_PER_mS, is decremented by 1 inside the isr. 
....................  * When int_count reaches 0, no of miliseconds is incremented by 1 
....................  */ 
.................... #int_RTCC 
.................... void clock_isr() { 
0420:  SLEEP
....................  
....................     if(--int_count==0) 
*
0094:  DECFSZ 2B,F
0095:  GOTO   09B
....................     { 
....................       ++mseconds; 
0096:  INCF   30,F
0097:  BTFSC  03.2
0098:  INCF   31,F
....................       int_count=INTS_PER_mS; 
0099:  MOVLW  13
009A:  MOVWF  2B
....................     } 
....................  
.................... } 
....................  
009B:  BCF    0B.2
009C:  BCF    0A.3
009D:  BCF    0A.4
009E:  GOTO   021
.................... #int_EXT 
.................... void rayCrossed_isr() 
.................... { 
....................  //  if(INPUT(PIN_B2)&& rayTwo!=1) 
....................    if(INPUT(PIN_B2)) 
*
00D2:  BSF    03.5
00D3:  BSF    06.2
00D4:  BCF    03.5
00D5:  BTFSS  06.2
00D6:  GOTO   0E5
....................    { 
....................       rayTwo = 1; 
00D7:  BSF    2F.1
....................       if(rayOne == 1) 
00D8:  BTFSS  2F.0
00D9:  GOTO   0E3
....................       { 
....................          if(checkTimer() == 1) 
00DA:  CALL   09F
00DB:  DECFSZ 78,W
00DC:  GOTO   0E1
....................          { 
....................             noOfPeople++ ; 
00DD:  INCF   29,F
00DE:  BTFSC  03.2
00DF:  INCF   2A,F
....................             number_changed=1; 
00E0:  BSF    2F.3
....................          } 
....................          rayOne = 0; 
00E1:  BCF    2F.0
....................          rayTwo = 0; 
00E2:  BCF    2F.1
....................       } 
....................       setTimer(); 
00E3:  CALL   0B8
....................    } 
....................  // else  if(INPUT(PIN_B1)&& rayOne!=1) 
....................    else if(INPUT(PIN_B1)) 
00E4:  GOTO   0F8
00E5:  BSF    03.5
00E6:  BSF    06.1
00E7:  BCF    03.5
00E8:  BTFSS  06.1
00E9:  GOTO   0F8
....................    { 
....................       rayOne = 1; 
00EA:  BSF    2F.0
....................       if(rayTwo == 1) 
00EB:  BTFSS  2F.1
00EC:  GOTO   0F7
....................       { 
....................          if(checkTimer() == 1) 
00ED:  CALL   09F
00EE:  DECFSZ 78,W
00EF:  GOTO   0F5
....................          { 
....................             noOfPeople-- ; 
00F0:  MOVF   29,W
00F1:  BTFSC  03.2
00F2:  DECF   2A,F
00F3:  DECF   29,F
....................             number_changed=1; 
00F4:  BSF    2F.3
....................          } 
....................          rayOne = 0; 
00F5:  BCF    2F.0
....................          rayTwo = 0; 
00F6:  BCF    2F.1
....................       } 
....................       setTimer(); 
00F7:  CALL   0B8
....................    } 
....................    delay_ms(MIN_DELAY_BETWEEN_TWO_INTERRUPTS); 
00F8:  MOVLW  01
00F9:  MOVWF  4B
00FA:  CALL   0BE
....................  } 
....................  
....................  
00FB:  BCF    0B.1
00FC:  BCF    0A.3
00FD:  BCF    0A.4
00FE:  GOTO   021
.................... void setTimer() 
.................... { 
....................    int_count=INTS_PER_mS; 
*
00B8:  MOVLW  13
00B9:  MOVWF  2B
....................    set_timer0(0); 
00BA:  CLRF   01
....................    mseconds=0; 
00BB:  CLRF   31
00BC:  CLRF   30
.................... } 
00BD:  RETLW  00
....................  
....................  
.................... /* When both rayOne =1 and rayTwo = 1, this is called */ 
.................... int checkTimer() 
.................... { 
....................    if((mseconds <= MAX_CROSSING_TIME) && (mseconds >= MIN_CROSSING_TIME)) 
*
009F:  MOVF   31,W
00A0:  SUBLW  07
00A1:  BTFSS  03.0
00A2:  GOTO   0B4
00A3:  BTFSS  03.2
00A4:  GOTO   0A9
00A5:  MOVF   30,W
00A6:  SUBLW  D0
00A7:  BTFSS  03.0
00A8:  GOTO   0B4
00A9:  MOVF   31,F
00AA:  BTFSS  03.2
00AB:  GOTO   0B0
00AC:  MOVF   30,W
00AD:  SUBLW  03
00AE:  BTFSC  03.0
00AF:  GOTO   0B4
....................    { 
....................       return 1; 
00B0:  MOVLW  01
00B1:  MOVWF  78
00B2:  GOTO   0B7
....................    } 
....................    else 
00B3:  GOTO   0B7
....................    { 
....................       return 0; 
00B4:  MOVLW  00
00B5:  MOVWF  78
00B6:  GOTO   0B7
....................    } 
.................... } 
00B7:  RETLW  00
....................  
.................... int32 convertToCelsius() 
.................... { 
....................    return (t*150)/307; 
*
03F1:  MOVF   35,W
03F2:  MOVWF  3A
03F3:  MOVF   34,W
03F4:  MOVWF  39
03F5:  CLRF   3C
03F6:  MOVLW  96
03F7:  MOVWF  3B
03F8:  GOTO   2DE
03F9:  MOVF   79,W
03FA:  MOVWF  3A
03FB:  MOVF   78,W
03FC:  MOVWF  39
03FD:  MOVF   79,W
03FE:  MOVWF  44
03FF:  MOVF   78,W
0400:  MOVWF  43
0401:  MOVLW  01
0402:  MOVWF  46
0403:  MOVLW  33
0404:  MOVWF  45
0405:  CALL   23B
0406:  MOVF   79,W
0407:  MOVWF  7A
0408:  MOVF   78,W
0409:  MOVWF  77
040A:  MOVF   79,W
040B:  MOVWF  78
040C:  CLRF   79
040D:  CLRF   7A
.................... } 
....................  
.................... void lcd_display_temperature() 
.................... { 
....................           temperature =read_temperature(); 
*
0412:  MOVF   79,W
0413:  MOVWF  33
0414:  MOVF   78,W
0415:  MOVWF  32
....................           lcd_display(temperature,13,2); 
0416:  MOVF   33,W
0417:  MOVWF  3A
0418:  MOVF   32,W
0419:  MOVWF  39
041A:  MOVLW  0D
041B:  MOVWF  3B
041C:  MOVLW  02
041D:  MOVWF  3C
041E:  CALL   269
.................... } 
....................  
.................... int convertToASCII(int16 number) 
.................... { 
....................    return (number+48); 
*
0260:  MOVLW  30
0261:  ADDWF  40,W
0262:  MOVWF  78
0263:  MOVF   41,W
0264:  MOVWF  7A
0265:  BTFSC  03.0
0266:  INCF   7A,F
0267:  MOVF   78,W
.................... } 
0268:  RETLW  00
....................  
.................... void lcd_display(int16 number, int x, int y) 
.................... { 
....................    int unitsPosition, tensPosition, hundredsPosition; 
....................  
....................        unitsPosition =number % 10; 
0269:  MOVF   3A,W
026A:  MOVWF  44
026B:  MOVF   39,W
026C:  MOVWF  43
026D:  CLRF   46
026E:  MOVLW  0A
026F:  MOVWF  45
0270:  CALL   23B
0271:  MOVF   77,W
0272:  MOVWF  3D
....................        tensPosition = ((number - (number % 10))%100)/10; 
0273:  MOVF   3A,W
0274:  MOVWF  44
0275:  MOVF   39,W
0276:  MOVWF  43
0277:  CLRF   46
0278:  MOVLW  0A
0279:  MOVWF  45
027A:  CALL   23B
027B:  MOVF   77,W
027C:  SUBWF  39,W
027D:  MOVWF  40
027E:  MOVF   3A,W
027F:  MOVWF  41
0280:  MOVF   7A,W
0281:  BTFSS  03.0
0282:  INCFSZ 7A,W
0283:  SUBWF  41,F
0284:  MOVF   41,W
0285:  MOVWF  44
0286:  MOVF   40,W
0287:  MOVWF  43
0288:  CLRF   46
0289:  MOVLW  64
028A:  MOVWF  45
028B:  CALL   23B
028C:  MOVF   77,W
028D:  MOVWF  41
028E:  MOVF   7A,W
028F:  MOVWF  42
0290:  MOVWF  44
0291:  MOVF   77,W
0292:  MOVWF  43
0293:  CLRF   46
0294:  MOVLW  0A
0295:  MOVWF  45
0296:  CALL   23B
0297:  MOVF   78,W
0298:  MOVWF  3E
....................        hundredsPosition = ((number - (number%100))%1000)/100; 
0299:  MOVF   3A,W
029A:  MOVWF  44
029B:  MOVF   39,W
029C:  MOVWF  43
029D:  CLRF   46
029E:  MOVLW  64
029F:  MOVWF  45
02A0:  CALL   23B
02A1:  MOVF   77,W
02A2:  SUBWF  39,W
02A3:  MOVWF  40
02A4:  MOVF   3A,W
02A5:  MOVWF  41
02A6:  MOVF   7A,W
02A7:  BTFSS  03.0
02A8:  INCFSZ 7A,W
02A9:  SUBWF  41,F
02AA:  MOVF   41,W
02AB:  MOVWF  44
02AC:  MOVF   40,W
02AD:  MOVWF  43
02AE:  MOVLW  03
02AF:  MOVWF  46
02B0:  MOVLW  E8
02B1:  MOVWF  45
02B2:  CALL   23B
02B3:  MOVF   77,W
02B4:  MOVWF  41
02B5:  MOVF   7A,W
02B6:  MOVWF  42
02B7:  MOVWF  44
02B8:  MOVF   77,W
02B9:  MOVWF  43
02BA:  CLRF   46
02BB:  MOVLW  64
02BC:  MOVWF  45
02BD:  CALL   23B
02BE:  MOVF   78,W
02BF:  MOVWF  3F
....................  
....................        lcd_gotoxy(x,y); 
02C0:  MOVF   3B,W
02C1:  MOVWF  42
02C2:  MOVF   3C,W
02C3:  MOVWF  43
02C4:  CALL   1FE
....................        lcd_putc(convertToASCII(hundredsPosition)); 
02C5:  CLRF   41
02C6:  MOVF   3F,W
02C7:  MOVWF  40
02C8:  CALL   260
02C9:  MOVF   78,W
02CA:  MOVWF  40
02CB:  MOVWF  41
02CC:  CALL   210
....................        lcd_putc(convertToASCII(tensPosition)); 
02CD:  CLRF   41
02CE:  MOVF   3E,W
02CF:  MOVWF  40
02D0:  CALL   260
02D1:  MOVF   78,W
02D2:  MOVWF  40
02D3:  MOVWF  41
02D4:  CALL   210
....................        lcd_putc(convertToASCII(unitsPosition)); 
02D5:  CLRF   41
02D6:  MOVF   3D,W
02D7:  MOVWF  40
02D8:  CALL   260
02D9:  MOVF   78,W
02DA:  MOVWF  40
02DB:  MOVWF  41
02DC:  CALL   210
.................... } 
02DD:  RETLW  00
....................  
.................... int16 read_temperature() 
.................... { 
....................     delay_ms(1000);                  //a small delay is required after setting the channel 
*
03CC:  MOVLW  04
03CD:  MOVWF  39
03CE:  CLRF   28
03CF:  BTFSC  0B.7
03D0:  BSF    28.7
03D1:  BCF    0B.7
03D2:  MOVLW  FA
03D3:  MOVWF  4B
03D4:  CALL   0BE
03D5:  BTFSC  28.7
03D6:  BSF    0B.7
03D7:  DECFSZ 39,F
03D8:  GOTO   3CE
....................     t = read_adc(); 
03D9:  BSF    1F.2
03DA:  BTFSC  1F.2
03DB:  GOTO   3DA
03DC:  BSF    03.5
03DD:  MOVF   1E,W
03DE:  BCF    03.5
03DF:  MOVWF  34
03E0:  MOVF   1E,W
03E1:  MOVWF  35
....................     if(pre_t==t) 
03E2:  MOVF   34,W
03E3:  SUBWF  36,W
03E4:  BTFSS  03.2
03E5:  GOTO   3EC
03E6:  MOVF   35,W
03E7:  SUBWF  37,W
03E8:  BTFSS  03.2
03E9:  GOTO   3EC
....................     { 
....................        temp_changed=0; 
03EA:  BCF    2F.4
....................     } 
....................     else 
03EB:  GOTO   3F1
....................     { 
....................        pre_t = t; 
03EC:  MOVF   35,W
03ED:  MOVWF  37
03EE:  MOVF   34,W
03EF:  MOVWF  36
....................        temp_changed=1; 
03F0:  BSF    2F.4
....................     } 
....................     return convertToCelsius(); 
*
040E:  MOVF   78,W
040F:  MOVWF  79
0410:  MOVF   77,W
0411:  MOVWF  78
.................... } 
....................  
.................... void initialDisplay() 
.................... { 
....................      delay_ms(25); 
*
031B:  MOVLW  19
031C:  MOVWF  4B
031D:  CALL   0BE
031E:  BTFSC  28.7
031F:  BSF    0B.7
....................      lcd_init(); 
....................     // delay_ms(6); 
....................  
....................      lcd_gotoxy(1,1); 
*
0359:  MOVLW  01
035A:  MOVWF  42
035B:  MOVWF  43
035C:  CALL   1FE
....................      lcd_putc("*****CSE'10*****"); 
035D:  CLRF   39
035E:  MOVF   39,W
035F:  CALL   042
0360:  IORLW  00
0361:  BTFSC  03.2
0362:  GOTO   367
0363:  INCF   39,F
0364:  MOVWF  41
0365:  CALL   210
0366:  GOTO   35E
0367:  MOVWF  41
0368:  CALL   210
....................      lcd_gotoxy(1,2); 
0369:  MOVLW  01
036A:  MOVWF  42
036B:  MOVLW  02
036C:  MOVWF  43
036D:  CALL   1FE
....................      lcd_putc("||||||||||||||||"); 
036E:  CLRF   39
036F:  MOVF   39,W
0370:  CALL   057
0371:  IORLW  00
0372:  BTFSC  03.2
0373:  GOTO   378
0374:  INCF   39,F
0375:  MOVWF  41
0376:  CALL   210
0377:  GOTO   36F
0378:  MOVWF  41
0379:  CALL   210
....................      delay_ms(2000); 
037A:  MOVLW  08
037B:  MOVWF  39
037C:  CLRF   28
037D:  BTFSC  0B.7
037E:  BSF    28.7
037F:  BCF    0B.7
0380:  MOVLW  FA
0381:  MOVWF  4B
0382:  CALL   0BE
0383:  BTFSC  28.7
0384:  BSF    0B.7
0385:  DECFSZ 39,F
0386:  GOTO   37C
....................      lcd_gotoxy(1,1); 
0387:  MOVLW  01
0388:  MOVWF  42
0389:  MOVWF  43
038A:  CALL   1FE
....................      lcd_putc("\fNumberInside:"); 
038B:  CLRF   39
038C:  MOVF   39,W
038D:  CALL   06C
038E:  IORLW  00
038F:  BTFSC  03.2
0390:  GOTO   395
0391:  INCF   39,F
0392:  MOVWF  41
0393:  CALL   210
0394:  GOTO   38C
0395:  MOVWF  41
0396:  CALL   210
....................      lcd_display(noOfPeople,14,1); 
0397:  MOVF   2A,W
0398:  MOVWF  3A
0399:  MOVF   29,W
039A:  MOVWF  39
039B:  MOVLW  0E
039C:  MOVWF  3B
039D:  MOVLW  01
039E:  MOVWF  3C
039F:  CALL   269
....................      lcd_gotoxy(1,2); 
03A0:  MOVLW  01
03A1:  MOVWF  42
03A2:  MOVLW  02
03A3:  MOVWF  43
03A4:  CALL   1FE
....................      lcd_putc("Temperature:   C"); 
03A5:  CLRF   39
03A6:  MOVF   39,W
03A7:  CALL   07F
03A8:  IORLW  00
03A9:  BTFSC  03.2
03AA:  GOTO   3AF
03AB:  INCF   39,F
03AC:  MOVWF  41
03AD:  CALL   210
03AE:  GOTO   3A6
03AF:  MOVWF  41
03B0:  CALL   210
....................  
.................... } 
....................  
.................... void init_pic() 
.................... { 
....................    setup_adc_ports(AN0); 
*
00FF:  BSF    03.5
0100:  BCF    1F.0
0101:  BSF    1F.1
0102:  BSF    1F.2
0103:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_32); 
0104:  BCF    1F.6
0105:  BCF    03.5
0106:  BCF    1F.6
0107:  BSF    1F.7
0108:  BSF    03.5
0109:  BSF    1F.7
010A:  BCF    03.5
010B:  BSF    1F.0
....................    setup_psp(PSP_DISABLED); 
010C:  BSF    03.5
010D:  BCF    09.4
....................    setup_spi(FALSE); 
010E:  BCF    03.5
010F:  BCF    14.5
0110:  BCF    38.5
0111:  MOVF   38,W
0112:  BSF    03.5
0113:  MOVWF  07
0114:  BCF    03.5
0115:  BSF    38.4
0116:  MOVF   38,W
0117:  BSF    03.5
0118:  MOVWF  07
0119:  BCF    03.5
011A:  BCF    38.3
011B:  MOVF   38,W
011C:  BSF    03.5
011D:  MOVWF  07
011E:  MOVLW  00
011F:  BCF    03.5
0120:  MOVWF  14
0121:  BSF    03.5
0122:  MOVWF  14
....................    setup_counters( RTCC_INTERNAL, RTCC_DIV_1 | RTCC_8_BIT); 
0123:  MOVLW  08
0124:  MOVWF  77
0125:  BTFSS  77.3
0126:  GOTO   132
0127:  MOVLW  07
0128:  BCF    03.5
0129:  CLRF   01
012A:  MOVLW  81
012B:  MOVWF  04
012C:  BCF    03.7
012D:  MOVF   00,W
012E:  ANDLW  C0
012F:  IORLW  0F
0130:  MOVWF  00
0131:  BSF    03.5
0132:  CLRWDT
0133:  MOVLW  81
0134:  MOVWF  04
0135:  MOVF   00,W
0136:  ANDLW  C0
0137:  IORWF  77,W
0138:  MOVWF  00
....................    setup_timer_1(T1_DISABLED); 
0139:  BCF    03.5
013A:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
013B:  MOVLW  00
013C:  MOVWF  78
013D:  MOVWF  12
013E:  MOVLW  00
013F:  BSF    03.5
0140:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
0141:  MOVLW  07
0142:  MOVWF  1C
0143:  MOVF   05,W
0144:  MOVLW  10
0145:  MOVWF  77
0146:  DECFSZ 77,F
0147:  GOTO   146
0148:  NOP
0149:  MOVF   1C,W
014A:  BCF    03.5
014B:  BCF    0D.6
....................    setup_vref(FALSE); 
014C:  BSF    03.5
014D:  CLRF   1D
....................    enable_interrupts(INT_RTCC); 
014E:  BCF    03.5
014F:  BSF    0B.5
....................    enable_interrupts(INT_EXT); 
0150:  BSF    0B.4
....................    enable_interrupts(GLOBAL); 
0151:  MOVLW  C0
0152:  IORWF  0B,F
....................  
....................    EXT_INT_EDGE(L_TO_H); 
0153:  BSF    03.5
0154:  BSF    01.6
....................  
....................    OUTPUT_B(0); 
0155:  CLRF   06
0156:  BCF    03.5
0157:  CLRF   06
....................    OUTPUT_C(0); 
0158:  MOVLW  00
0159:  MOVWF  38
015A:  BSF    03.5
015B:  CLRF   07
015C:  BCF    03.5
015D:  CLRF   07
....................  
....................    SET_TRIS_B(0b00000111);   //pins B0, B1 and B2 are set to give inputs. b0 is the external interuupt pin 
015E:  MOVLW  07
015F:  BSF    03.5
0160:  MOVWF  06
....................    SET_TRIS_C(0b00000000); 
0161:  MOVLW  00
0162:  MOVWF  07
0163:  BCF    03.5
0164:  MOVWF  38
....................    SET_TRIS_D(0b00000000); 
0165:  BSF    03.5
0166:  MOVWF  08
....................  
....................    set_adc_channel(0);            //the next read_adc call will read channel 0 
0167:  MOVWF  78
0168:  BCF    03.5
0169:  MOVF   1F,W
016A:  ANDLW  C7
016B:  IORWF  78,W
016C:  MOVWF  1F
.................... } 
016D:  BCF    0A.3
016E:  BCF    0A.4
016F:  GOTO   317 (RETURN)
....................  
.................... void phaseControl() 
.................... { 
....................  
....................   /* switch(noOfPeople) 
....................    { 
....................  
....................    case 0 : OUTPUT_HIGH(PIN_B7); 
....................             break; 
....................  
....................    default : 
....................    if(INPUT(PIN_B6) && pin_changed == 1) 
....................    { 
....................          pin_changed = 0; 
....................          if(0<=temperature && temperature<35) 
....................          { 
....................             OUTPUT_HIGH(PIN_B7); 
....................          } 
....................        else if(temperature>=35&& temperature<45) 
....................        { 
....................            delay_ms(5); 
....................            OUTPUT_HIGH(PIN_B7); 
....................             delay_ms(5); 
....................             OUTPUT_LOW(PIN_B7); 
....................  
....................        } 
....................        else if(temperature>=45) 
....................        { 
....................             OUTPUT_LOW(PIN_B7); 
....................        } 
....................    } 
....................    //else if(!INPUT(PIN_B6) && pin_changed==0) pin_changed = 1; 
....................    if(!INPUT(PIN_B6)) pin_changed = 1; 
....................    }*/ 
....................  
....................    if(noOfPeople==0) 
....................    { 
....................       OUTPUT_HIGH(PIN_B7); 
....................       //OUTPUT_LOW(PIN_B7); 
....................    } 
....................    else if(noOfPeople>0) 
....................    { 
....................       if(INPUT(PIN_B6) && pin_changed == 1) 
....................    { 
....................          pin_changed = 0; 
....................          if(0<=temperature && temperature<25) 
....................          { 
....................             OUTPUT_HIGH(PIN_B7); 
....................          } 
....................        else if(temperature>=25&& temperature<35) 
....................        { 
....................             delay_ms(5); 
....................             OUTPUT_HIGH(PIN_B7); 
....................             delay_ms(5); 
....................             OUTPUT_LOW(PIN_B7); 
....................  
....................        } 
....................        else if(temperature>=35) 
....................        { 
....................             OUTPUT_LOW(PIN_B7); 
....................        } 
....................    } 
....................    //else if(!INPUT(PIN_B6) && pin_changed==0) pin_changed = 1; 
....................    if(!INPUT(PIN_B6)) pin_changed = 1; 
....................    } 
....................  
....................  
.................... } 

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
